ESP32 智慧鬧鐘系統 (非同步 AIoT 架構)這是一個基於 MicroPython uasyncio 框架開發的智慧鬧鐘系統。本專案不僅實現了基本的定時響鈴功能，更整合了 MQTT 遠端控制、Web 介面設定、溫濕度監測與 OLED 資訊顯示，展現了現代物聯網裝置的「多工處理」與「高解耦」設計思維。🌟 核心特色非同步並行處理 (Asynchronous Multitasking)：採用 uasyncio 驅動，確保 MQTT 指令接收、網頁伺服器回應、鬧鐘偵測與 UI 更新互不阻塞。雙通道控制 (Dual-Channel Control)：同時提供網頁 UI 與 MQTT 遠端指令兩種操作途徑，數據透過 AlarmManager 統一同步。裝飾器路由機制 (Decorator Routing)：參考 Flask 框架，利用 Python 裝飾器簡化 MQTT 訊息的分發邏輯。資料持久化 (Persistence)：鬧鐘設定自動儲存於 Flash 中的 alarms.json，斷電不遺失。📂 專案結構檔案名稱職責說明main.py系統入口。負責初始化硬體、建立依賴並啟動 Event Loop。config.py全域配置。集中管理 GPIO 腳位、WiFi 帳密與 MQTT Topic 定義。tasks.py任務邏輯。定義 OLED 刷新、鬧鐘檢查與 MQTT 路由分發等協程任務。hardware/硬體抽象層。封裝了 display.py (OLED)、sensors.py (DHT11) 等驅動。communication/通訊介面層。包含 mqtt_client.py、mqtt_router.py、web_server.py 與 wifi.py。utils/工具程式。包含負責檔案存取的 alarm_manager.py。🛠️ 硬體需求ESP32 開發板SSD1306 OLED 顯示器 (I2C)DHT11 溫濕度感測器有源蜂鳴器 (Buzzer)微動開關 (按鈕) x 2🚀 快速開始1. 環境配置請先確保 ESP32 已燒錄 MicroPython 韌體，並在 config.py 中修改以下資訊：WiFi 設定：在 WIFI_PROFILES 中加入你的 SSID 與密碼。MQTT 設定：可保持預設的 test.mosquitto.org，但請確認 DEVICE_ID 的唯一性。2. 部署程式碼使用 Thonny 或 ampy 將所有資料夾與 .py 檔案上傳至 ESP32。3. 操作說明網頁控制：連線後，OLED 會顯示 ESP32 的 IP 地址。在瀏覽器輸入該 IP 即可開啟鬧鐘設定頁面。硬體按鈕：BUTTON_NEXT：切換 OLED 顯示不同的鬧鐘資訊。BUTTON_STOP：響鈴時按下可關閉鬧鐘。🛰️ MQTT 指令範例 (JSON 格式)使用 MQTTX 等工具發送到 nuu/csie/你的DEVICE_ID/ 開頭的 Topic：新增鬧鐘 (.../alarm_add)：{"h": 8, "m": 30, "days": ["Mon", "Fri"]}。刪除鬧鐘 (.../alarm_delete)：{"index": 0}。查詢列表 (.../alarm_list)：發送任意內容，裝置將在 .../response 回傳目前清單。⚠️ 開發者筆記：MQTT 除錯與坑在開發過程中，若遇到「MQTTX 設定正確且顯示連線，但 ESP32 卻收不到訊息」的情況，請注意：Client ID 衝突：若兩台裝置使用相同的 ID 連接同一個 Broker，會發生互踢現象，導致訊息傳輸中斷。Topic 嚴格匹配：請檢查 Topic 是否包含隱藏空格或多餘的 /。非同步安全解碼：本系統在 mqtt_client.py 實作了「絕對防禦版」的 on_message。它能自動處理 bytes 與 str 的轉換，並印出 [Debug RAW] 資訊，這是在除錯時最重要的依據。自我測試：系統啟動時會發送一條 self_test 訊息給自己，藉此驗證通訊鏈路是否通暢。📝 結語本專案示範了如何透過「分層架構」與「非同步併發」將複雜的物聯網需求模組化。資工系的核心競爭力不在於寫出程式碼，而在於設計出能應對異常情況、具備擴充性且易於維護的系統架構。
